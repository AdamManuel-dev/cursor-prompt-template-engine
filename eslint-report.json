[{"filePath":"/Users/adammanuel/Projects/cursor-prompt-template-engine/src/commands/apply.ts","messages":[{"ruleId":"import/extensions","severity":2,"message":"Missing file extension for \"../core/template-engine\"","line":15,"column":32,"nodeType":"Literal","endLine":15,"endColumn":57},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../core/template-engine'.","line":15,"column":32,"nodeType":"Literal","endLine":15,"endColumn":57},{"ruleId":"import/extensions","severity":2,"message":"Missing file extension for \"../core/template-validator\"","line":16,"column":35,"nodeType":"Literal","endLine":16,"endColumn":63},{"ruleId":"import/no-unresolved","severity":2,"message":"Unable to resolve path to module '../core/template-validator'.","line":16,"column":35,"nodeType":"Literal","endLine":16,"endColumn":63},{"ruleId":"no-use-before-define","severity":2,"message":"'findTemplate' was used before it was defined.","line":48,"column":32,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":48,"endColumn":44},{"ruleId":"no-use-before-define","severity":2,"message":"'loadTemplate' was used before it was defined.","line":54,"column":28,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":54,"endColumn":40},{"ruleId":"no-use-before-define","severity":2,"message":"'previewApply' was used before it was defined.","line":71,"column":13,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":71,"endColumn":25},{"ruleId":"no-use-before-define","severity":2,"message":"'applyTemplate' was used before it was defined.","line":76,"column":26,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":76,"endColumn":39},{"ruleId":"no-use-before-define","severity":2,"message":"'reportApplyResults' was used before it was defined.","line":79,"column":5,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":79,"endColumn":23},{"ruleId":"no-restricted-syntax","severity":2,"message":"iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.","line":100,"column":3,"nodeType":"ForOfStatement","messageId":"restrictedSyntax","endLine":120,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3426,3429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3426,3429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-underscore-dangle","severity":2,"message":"Unexpected dangling '_' in '_basePath'.","line":136,"column":5,"nodeType":"MemberExpression","messageId":"unexpectedUnderscore","endLine":136,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4305,4308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4305,4308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4755,4758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4755,4758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-nested-ternary","severity":2,"message":"Do not nest ternary expressions.","line":171,"column":22,"nodeType":"ConditionalExpression","messageId":"noNestedTernary","endLine":175,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5237,5240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5237,5240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5561,5564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5561,5564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":203,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5711,5714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5711,5714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-use-before-define","severity":2,"message":"'getDefaultVariables' was used before it was defined.","line":220,"column":10,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":220,"endColumn":29},{"ruleId":"no-restricted-syntax","severity":2,"message":"iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.","line":227,"column":7,"nodeType":"ForOfStatement","messageId":"restrictedSyntax","endLine":244,"endColumn":8},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":229,"column":27,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":229,"endColumn":76},{"ruleId":"no-use-before-define","severity":2,"message":"'applyFile' was used before it was defined.","line":229,"column":33,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":229,"endColumn":42},{"ruleId":"no-restricted-syntax","severity":2,"message":"iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.","line":249,"column":7,"nodeType":"ForOfStatement","messageId":"restrictedSyntax","endLine":257,"endColumn":8},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":251,"column":11,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":251,"endColumn":47},{"ruleId":"no-use-before-define","severity":2,"message":"'executeCommand' was used before it was defined.","line":251,"column":17,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":251,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":273,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7630,7633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7630,7633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":274,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7663,7666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7663,7666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8787,8790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8787,8790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'variables' is defined but never used. Allowed unused args must match /^_/u.","line":321,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":321,"endColumn":12},{"ruleId":"no-unused-vars","severity":2,"message":"'variables' is defined but never used.","line":321,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":321,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":321,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8820,8823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8820,8823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9139,9142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9139,9142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Apply command implementation for cursor-prompt-template-engine\n * @lastmodified 2025-08-22T11:50:00Z\n *\n * Features: Apply prompt templates to current project\n * Main APIs: applyCommand()\n * Constraints: Requires valid template in templates directory\n * Patterns: Uses template validation and file system operations\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport { logger } from '../utils/logger';\nimport { TemplateEngine } from '../core/template-engine';\nimport { TemplateValidator } from '../core/template-validator';\nimport { ConfigManager } from '../utils/config';\n\nexport interface ApplyOptions {\n  force?: boolean;\n  preview?: boolean;\n  variables?: Record<string, string>;\n}\n\ninterface ApplyResult {\n  success: boolean;\n  filesCreated: string[];\n  filesUpdated: string[];\n  filesSkipped: string[];\n  errors: string[];\n}\n\n/**\n * Apply a prompt template to the current project\n */\nexport async function applyCommand(\n  templateName: string,\n  options: ApplyOptions = {}\n): Promise<void> {\n  try {\n    logger.info(chalk.blue(`⚡ Applying template: ${templateName}`));\n\n    // Initialize config manager\n    const config = ConfigManager.getInstance();\n    const templateDirs = config.getTemplateDirectories();\n\n    // Find template\n    const templatePath = await findTemplate(templateName, templateDirs);\n    if (!templatePath) {\n      throw new Error(`Template '${templateName}' not found`);\n    }\n\n    // Load and validate template\n    const template = await loadTemplate(templatePath);\n    const validator = new TemplateValidator();\n    const validation = await validator.validate(template);\n\n    if (!validation.valid) {\n      logger.error(chalk.red('❌ Template validation failed:'));\n      validation.errors.forEach(err => {\n        logger.error(chalk.red(`  - ${err}`));\n      });\n      throw new Error('Invalid template');\n    }\n\n    // Preview mode\n    if (options.preview) {\n      logger.info(\n        chalk.yellow('\\n📋 Preview mode - no files will be modified')\n      );\n      await previewApply(template, options);\n      return;\n    }\n\n    // Apply template\n    const result = await applyTemplate(template, options);\n\n    // Report results\n    reportApplyResults(result);\n\n    if (!result.success) {\n      throw new Error('Template application failed');\n    }\n\n    logger.success(chalk.green('\\n✅ Template applied successfully!'));\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    logger.error(chalk.red(`❌ Apply failed: ${message}`));\n    throw error;\n  }\n}\n\n/**\n * Find template in configured directories\n */\nasync function findTemplate(\n  templateName: string,\n  directories: string[]\n): Promise<string | null> {\n  for (const dir of directories) {\n    const templatePath = path.join(dir, templateName);\n\n    // Check for directory with template.json\n    const templateJsonPath = path.join(templatePath, 'template.json');\n    if (fs.existsSync(templateJsonPath)) {\n      return templatePath;\n    }\n\n    // Check for .json file\n    const jsonPath = `${templatePath}.json`;\n    if (fs.existsSync(jsonPath)) {\n      return jsonPath;\n    }\n\n    // Check for .yaml file\n    const yamlPath = `${templatePath}.yaml`;\n    if (fs.existsSync(yamlPath)) {\n      return yamlPath;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Load template from file\n */\nasync function loadTemplate(templatePath: string): Promise<any> {\n  const stats = fs.statSync(templatePath);\n\n  if (stats.isDirectory()) {\n    // Load from template.json in directory\n    const templateJsonPath = path.join(templatePath, 'template.json');\n    const content = fs.readFileSync(templateJsonPath, 'utf8');\n    const template = JSON.parse(content);\n    template._basePath = templatePath;\n    return template;\n  }\n  // Load from single file\n  const content = fs.readFileSync(templatePath, 'utf8');\n\n  if (templatePath.endsWith('.json')) {\n    return JSON.parse(content);\n  }\n  if (templatePath.endsWith('.yaml') || templatePath.endsWith('.yml')) {\n    // TODO: Add YAML support\n    throw new Error('YAML templates not yet supported');\n  } else {\n    throw new Error(\n      `Unsupported template format: ${path.extname(templatePath)}`\n    );\n  }\n}\n\n/**\n * Preview template application\n */\nasync function previewApply(\n  template: any,\n  options: ApplyOptions\n): Promise<void> {\n  logger.info(chalk.cyan('\\nTemplate Information:'));\n  logger.info(`  Name: ${template.name || 'Unknown'}`);\n  logger.info(`  Description: ${template.description || 'No description'}`);\n  logger.info(`  Version: ${template.version || '1.0.0'}`);\n\n  if (template.files && Array.isArray(template.files)) {\n    logger.info(chalk.cyan('\\nFiles to be created/updated:'));\n    template.files.forEach((file: any) => {\n      const filePath = file.path || file.name;\n      const action = fs.existsSync(filePath)\n        ? options.force\n          ? '(overwrite)'\n          : '(skip - exists)'\n        : '(create)';\n      logger.info(`  ${filePath} ${chalk.gray(action)}`);\n    });\n  }\n\n  if (template.variables && Object.keys(template.variables).length > 0) {\n    logger.info(chalk.cyan('\\nRequired variables:'));\n    Object.entries(template.variables).forEach(\n      ([key, config]: [string, any]) => {\n        const value =\n          options.variables?.[key] || config.default || '<not provided>';\n        logger.info(`  ${key}: ${value}`);\n      }\n    );\n  }\n\n  if (template.commands && Array.isArray(template.commands)) {\n    logger.info(chalk.cyan('\\nCommands to execute:'));\n    template.commands.forEach((cmd: any) => {\n      logger.info(`  ${cmd.command || cmd}`);\n    });\n  }\n}\n\n/**\n * Apply template to project\n */\nasync function applyTemplate(\n  template: any,\n  options: ApplyOptions\n): Promise<ApplyResult> {\n  const result: ApplyResult = {\n    success: false,\n    filesCreated: [],\n    filesUpdated: [],\n    filesSkipped: [],\n    errors: [],\n  };\n\n  try {\n    // Initialize template engine\n    const engine = new TemplateEngine();\n\n    // Process variables\n    const variables = {\n      ...getDefaultVariables(),\n      ...(template.variables || {}),\n      ...(options.variables || {}),\n    };\n\n    // Apply files\n    if (template.files && Array.isArray(template.files)) {\n      for (const file of template.files) {\n        try {\n          const applied = await applyFile(file, variables, options, engine);\n          if (applied.created) {\n            result.filesCreated.push(applied.path);\n          } else if (applied.updated) {\n            result.filesUpdated.push(applied.path);\n          } else if (applied.skipped) {\n            result.filesSkipped.push(applied.path);\n          }\n        } catch (error) {\n          const message =\n            error instanceof Error ? error.message : String(error);\n          result.errors.push(\n            `Failed to apply ${file.path || file.name}: ${message}`\n          );\n        }\n      }\n    }\n\n    // Execute commands\n    if (template.commands && Array.isArray(template.commands)) {\n      for (const cmd of template.commands) {\n        try {\n          await executeCommand(cmd, variables);\n        } catch (error) {\n          const message =\n            error instanceof Error ? error.message : String(error);\n          result.errors.push(`Failed to execute command: ${message}`);\n        }\n      }\n    }\n\n    result.success = result.errors.length === 0;\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    result.errors.push(`Template application error: ${message}`);\n  }\n\n  return result;\n}\n\n/**\n * Apply individual file from template\n */\nasync function applyFile(\n  file: any,\n  variables: Record<string, any>,\n  options: ApplyOptions,\n  engine: TemplateEngine\n): Promise<{\n  path: string;\n  created?: boolean;\n  updated?: boolean;\n  skipped?: boolean;\n}> {\n  const filePath = file.path || file.name;\n  const fullPath = path.resolve(filePath);\n\n  // Check if file exists\n  const exists = fs.existsSync(fullPath);\n  if (exists && !options.force) {\n    logger.warn(chalk.yellow(`⚠️  Skipping existing file: ${filePath}`));\n    return { path: filePath, skipped: true };\n  }\n\n  // Process content\n  let content = file.content || '';\n  if (file.template) {\n    content = await engine.render(file.template, variables);\n  }\n\n  // Ensure directory exists\n  const dir = path.dirname(fullPath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  // Write file\n  fs.writeFileSync(fullPath, content, 'utf8');\n\n  if (exists) {\n    logger.info(chalk.green(`✓ Updated: ${filePath}`));\n    return { path: filePath, updated: true };\n  }\n  logger.info(chalk.green(`✓ Created: ${filePath}`));\n  return { path: filePath, created: true };\n}\n\n/**\n * Execute command from template\n */\nasync function executeCommand(\n  cmd: any,\n  variables: Record<string, any>\n): Promise<void> {\n  const command = typeof cmd === 'string' ? cmd : cmd.command;\n  if (!command) return;\n\n  // TODO: Implement command execution with variable substitution\n  logger.info(chalk.gray(`  Would execute: ${command}`));\n}\n\n/**\n * Get default variables\n */\nfunction getDefaultVariables(): Record<string, any> {\n  return {\n    projectName: path.basename(process.cwd()),\n    projectPath: process.cwd(),\n    timestamp: new Date().toISOString(),\n    year: new Date().getFullYear(),\n  };\n}\n\n/**\n * Report apply results\n */\nfunction reportApplyResults(result: ApplyResult): void {\n  logger.info(chalk.cyan('\\n📊 Apply Results:'));\n\n  if (result.filesCreated.length > 0) {\n    logger.info(chalk.green(`  ✓ Created ${result.filesCreated.length} files`));\n  }\n\n  if (result.filesUpdated.length > 0) {\n    logger.info(chalk.blue(`  ✓ Updated ${result.filesUpdated.length} files`));\n  }\n\n  if (result.filesSkipped.length > 0) {\n    logger.info(\n      chalk.yellow(`  ⚠ Skipped ${result.filesSkipped.length} files`)\n    );\n  }\n\n  if (result.errors.length > 0) {\n    logger.error(chalk.red(`  ✗ ${result.errors.length} errors occurred:`));\n    result.errors.forEach(err => {\n      logger.error(chalk.red(`    - ${err}`));\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/Users/adammanuel/Projects/cursor-prompt-template-engine/src/commands/validate.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3145,3148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3145,3148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3197,3200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3197,3200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-plusplus","severity":2,"message":"Unary operator '++' used.","line":234,"column":39,"nodeType":"UpdateExpression","messageId":"unexpectedUnaryOp","endLine":234,"endColumn":42},{"ruleId":"no-continue","severity":2,"message":"Unexpected use of continue statement.","line":244,"column":9,"nodeType":"ContinueStatement","messageId":"unexpected","endLine":244,"endColumn":18},{"ruleId":"no-continue","severity":2,"message":"Unexpected use of continue statement.","line":256,"column":9,"nodeType":"ContinueStatement","messageId":"unexpected","endLine":256,"endColumn":18},{"ruleId":"no-continue","severity":2,"message":"Unexpected use of continue statement.","line":265,"column":9,"nodeType":"ContinueStatement","messageId":"unexpected","endLine":265,"endColumn":18},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":271,"column":9,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":271,"endColumn":36},{"ruleId":"class-methods-use-this","severity":2,"message":"Expected 'this' to be used by class method 'isObject'.","line":464,"column":3,"nodeType":"FunctionExpression","messageId":"missingThis","endLine":464,"endColumn":19},{"ruleId":"no-restricted-syntax","severity":2,"message":"iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.","line":567,"column":3,"nodeType":"ForOfStatement","messageId":"restrictedSyntax","endLine":603,"endColumn":4},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":569,"column":7,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":569,"endColumn":34},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":574,"column":9,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":574,"endColumn":36},{"ruleId":"no-restricted-syntax","severity":2,"message":"iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.","line":582,"column":7,"nodeType":"ForOfStatement","messageId":"restrictedSyntax","endLine":590,"endColumn":8},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":585,"column":11,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":585,"endColumn":35},{"ruleId":"no-await-in-loop","severity":2,"message":"Unexpected `await` inside a loop.","line":595,"column":9,"nodeType":"AwaitExpression","messageId":"unexpectedAwait","endLine":595,"endColumn":33},{"ruleId":"no-use-before-define","severity":2,"message":"'displayTableResults' was used before it was defined.","line":634,"column":7,"nodeType":"Identifier","messageId":"usedBeforeDefined","endLine":634,"endColumn":26},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎`","line":803,"column":1,"nodeType":null,"messageId":"delete","endLine":804,"endColumn":1,"fix":{"range":[22750,22751],"text":""}}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * @fileoverview Validate command for cursor-prompt-template-engine\n * @lastmodified 2025-08-22T18:30:00Z\n *\n * Features: Template validation with comprehensive checks\n * Main APIs: validateCommand() - validates template structure and integrity\n * Constraints: Validates required fields, file references, and variable definitions\n * Patterns: Template loading, schema validation, detailed error reporting\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport { logger } from '../utils/logger';\nimport {\n  TemplateEngineError,\n  ValidationError,\n  FileNotFoundError,\n} from '../utils/errors';\nimport { loadConfig, Config } from '../utils/config';\nimport {\n  ValidationResult,\n  ValidationError as IValidationError,\n  ValidationWarning,\n} from '../types';\n\nexport interface ValidateOptions {\n  strict?: boolean;\n  fix?: boolean;\n  format?: 'table' | 'json' | 'yaml';\n  detailed?: boolean;\n}\n\nexport interface TemplateValidationResult extends ValidationResult {\n  templatePath: string;\n  templateName: string;\n  schema: {\n    hasRequiredFields: boolean;\n    hasValidFileReferences: boolean;\n    hasValidVariables: boolean;\n  };\n}\n\n/**\n * Template validator class\n */\nclass TemplateValidator {\n  private strict: boolean;\n\n  constructor(options: { strict?: boolean } = {}) {\n    this.strict = options.strict ?? false;\n  }\n\n  /**\n   * Validate a loaded template configuration\n   */\n  async validateTemplate(\n    template: unknown,\n    templatePath: string\n  ): Promise<TemplateValidationResult> {\n    const errors: IValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n    const templateName = this.extractTemplateName(template, templatePath);\n\n    // Initialize schema validation flags\n    const schema = {\n      hasRequiredFields: false,\n      hasValidFileReferences: false,\n      hasValidVariables: false,\n    };\n\n    try {\n      // Validate basic structure\n      this.validateBasicStructure(template, errors);\n\n      // Validate required fields\n      schema.hasRequiredFields = this.validateRequiredFields(template, errors);\n\n      // Validate file references if template has files\n      schema.hasValidFileReferences = await this.validateFileReferences(\n        template,\n        templatePath,\n        errors,\n        warnings\n      );\n\n      // Validate variable definitions\n      schema.hasValidVariables = this.validateVariableDefinitions(\n        template,\n        errors,\n        warnings\n      );\n\n      // Strict mode additional validations\n      if (this.strict) {\n        this.performStrictValidations(template, templatePath, errors, warnings);\n      }\n    } catch (error) {\n      errors.push({\n        code: 'VALIDATION_EXCEPTION',\n        message: `Validation failed: ${error}`,\n        file: templatePath,\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n      templatePath,\n      templateName,\n      schema,\n    };\n  }\n\n  /**\n   * Extract template name from template or path\n   */\n  private extractTemplateName(template: unknown, templatePath: string): string {\n    if (this.isObject(template) && typeof (template as any).name === 'string') {\n      return (template as any).name;\n    }\n    return path.basename(templatePath, path.extname(templatePath));\n  }\n\n  /**\n   * Validate basic template structure\n   */\n  private validateBasicStructure(\n    template: unknown,\n    errors: IValidationError[]\n  ): void {\n    if (!template) {\n      errors.push({\n        code: 'EMPTY_TEMPLATE',\n        message: 'Template is empty or null',\n      });\n      return;\n    }\n\n    if (!this.isObject(template)) {\n      errors.push({\n        code: 'INVALID_TEMPLATE_TYPE',\n        message: 'Template must be an object',\n      });\n    }\n  }\n\n  /**\n   * Validate required fields\n   */\n  private validateRequiredFields(\n    template: unknown,\n    errors: IValidationError[]\n  ): boolean {\n    if (!this.isObject(template)) return false;\n\n    const templateObj = template as Record<string, unknown>;\n    const requiredFields = ['name', 'description', 'version'];\n    let allFieldsValid = true;\n\n    requiredFields.forEach(field => {\n      if (!(field in templateObj) || !templateObj[field]) {\n        errors.push({\n          code: 'MISSING_REQUIRED_FIELD',\n          message: `Missing required field: ${field}`,\n        });\n        allFieldsValid = false;\n      } else if (typeof templateObj[field] !== 'string') {\n        errors.push({\n          code: 'INVALID_FIELD_TYPE',\n          message: `Field '${field}' must be a string`,\n        });\n        allFieldsValid = false;\n      } else if ((templateObj[field] as string).trim().length === 0) {\n        errors.push({\n          code: 'EMPTY_REQUIRED_FIELD',\n          message: `Required field '${field}' cannot be empty`,\n        });\n        allFieldsValid = false;\n      }\n    });\n\n    return allFieldsValid;\n  }\n\n  /**\n   * Validate file references exist\n   */\n  private async validateFileReferences(\n    template: unknown,\n    templatePath: string,\n    errors: IValidationError[],\n    warnings: ValidationWarning[]\n  ): Promise<boolean> {\n    if (!this.isObject(template)) return false;\n\n    const templateObj = template as Record<string, unknown>;\n    const { files } = templateObj;\n\n    // If no files array, that's valid but we'll warn in strict mode\n    if (!files) {\n      if (this.strict) {\n        warnings.push({\n          code: 'NO_FILES_DEFINED',\n          message: 'Template has no files defined',\n          suggestion:\n            'Consider adding a files array if this template should create files',\n        });\n      }\n      return true;\n    }\n\n    if (!Array.isArray(files)) {\n      errors.push({\n        code: 'INVALID_FILES_TYPE',\n        message: 'Template files must be an array',\n      });\n      return false;\n    }\n\n    if (files.length === 0) {\n      warnings.push({\n        code: 'EMPTY_FILES_ARRAY',\n        message: 'Template has empty files array',\n        suggestion: 'Remove the files array or add file definitions',\n      });\n      return true;\n    }\n\n    const templateDir = path.dirname(templatePath);\n    let allFilesValid = true;\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const fileIndex = `files[${i}]`;\n\n      if (!this.isObject(file)) {\n        errors.push({\n          code: 'INVALID_FILE_TYPE',\n          message: `${fileIndex} must be an object`,\n        });\n        allFilesValid = false;\n        continue;\n      }\n\n      const fileObj = file as Record<string, unknown>;\n\n      // Validate required file properties\n      if (!fileObj.source || typeof fileObj.source !== 'string') {\n        errors.push({\n          code: 'MISSING_FILE_SOURCE',\n          message: `${fileIndex} missing required 'source' property`,\n        });\n        allFilesValid = false;\n        continue;\n      }\n\n      if (!fileObj.destination || typeof fileObj.destination !== 'string') {\n        errors.push({\n          code: 'MISSING_FILE_DESTINATION',\n          message: `${fileIndex} missing required 'destination' property`,\n        });\n        allFilesValid = false;\n        continue;\n      }\n\n      // Check if source file exists\n      const sourcePath = path.resolve(templateDir, fileObj.source as string);\n      try {\n        await fs.access(sourcePath);\n      } catch {\n        errors.push({\n          code: 'SOURCE_FILE_NOT_FOUND',\n          message: `${fileIndex} source file not found: ${fileObj.source}`,\n          file: sourcePath,\n        });\n        allFilesValid = false;\n      }\n\n      // Validate permissions format if specified\n      if (\n        fileObj.permissions &&\n        typeof fileObj.permissions === 'string' &&\n        !/^[0-7]{3,4}$/.test(fileObj.permissions)\n      ) {\n        errors.push({\n          code: 'INVALID_PERMISSIONS',\n          message: `${fileIndex} invalid permissions format: ${fileObj.permissions}`,\n        });\n        allFilesValid = false;\n      }\n    }\n\n    return allFilesValid;\n  }\n\n  /**\n   * Validate variable definitions\n   */\n  private validateVariableDefinitions(\n    template: unknown,\n    errors: IValidationError[],\n    warnings: ValidationWarning[]\n  ): boolean {\n    if (!this.isObject(template)) return false;\n\n    const templateObj = template as Record<string, unknown>;\n    const { variables } = templateObj;\n\n    // Variables are optional\n    if (!variables) return true;\n\n    if (!this.isObject(variables)) {\n      errors.push({\n        code: 'INVALID_VARIABLES_TYPE',\n        message: 'Template variables must be an object',\n      });\n      return false;\n    }\n\n    const variablesObj = variables as Record<string, unknown>;\n    let allVariablesValid = true;\n\n    Object.entries(variablesObj).forEach(([varName, varDef]) => {\n      if (!this.isObject(varDef)) {\n        errors.push({\n          code: 'INVALID_VARIABLE_TYPE',\n          message: `Variable '${varName}' must be an object`,\n        });\n        allVariablesValid = false;\n        return;\n      }\n\n      const variable = varDef as Record<string, unknown>;\n\n      // Validate variable type\n      const validTypes = ['string', 'number', 'boolean', 'choice'];\n      if (\n        !variable.type ||\n        typeof variable.type !== 'string' ||\n        !validTypes.includes(variable.type)\n      ) {\n        errors.push({\n          code: 'INVALID_VARIABLE_TYPE_VALUE',\n          message: `Variable '${varName}' has invalid type. Must be one of: ${validTypes.join(', ')}`,\n        });\n        allVariablesValid = false;\n      }\n\n      // Validate description\n      if (!variable.description || typeof variable.description !== 'string') {\n        errors.push({\n          code: 'MISSING_VARIABLE_DESCRIPTION',\n          message: `Variable '${varName}' must have a description`,\n        });\n        allVariablesValid = false;\n      }\n\n      // Validate choices for choice type\n      if (variable.type === 'choice') {\n        if (!variable.choices || !Array.isArray(variable.choices)) {\n          errors.push({\n            code: 'MISSING_VARIABLE_CHOICES',\n            message: `Variable '${varName}' of type 'choice' must have a choices array`,\n          });\n          allVariablesValid = false;\n        } else if ((variable.choices as unknown[]).length === 0) {\n          errors.push({\n            code: 'EMPTY_VARIABLE_CHOICES',\n            message: `Variable '${varName}' must have at least one choice`,\n          });\n          allVariablesValid = false;\n        }\n      }\n\n      // Validate default value type consistency\n      if (variable.default !== undefined) {\n        const defaultType = typeof variable.default;\n        if (variable.type === 'number' && defaultType !== 'number') {\n          warnings.push({\n            code: 'VARIABLE_TYPE_MISMATCH',\n            message: `Variable '${varName}' default value type doesn't match variable type`,\n            suggestion: `Convert default value to ${variable.type}`,\n          });\n        }\n      }\n    });\n\n    return allVariablesValid;\n  }\n\n  /**\n   * Perform strict mode validations\n   */\n  private performStrictValidations(\n    template: unknown,\n    templatePath: string,\n    errors: IValidationError[],\n    warnings: ValidationWarning[]\n  ): void {\n    if (!this.isObject(template)) return;\n\n    const templateObj = template as Record<string, unknown>;\n\n    // Check for recommended fields\n    const recommendedFields = ['author', 'tags', 'type'];\n    recommendedFields.forEach(field => {\n      if (!(field in templateObj) || !templateObj[field]) {\n        warnings.push({\n          code: 'MISSING_RECOMMENDED_FIELD',\n          message: `Missing recommended field: ${field}`,\n          suggestion: `Consider adding '${field}' for better template discoverability`,\n        });\n      }\n    });\n\n    // Validate version format\n    if (templateObj.version && typeof templateObj.version === 'string') {\n      const versionPattern = /^\\d+\\.\\d+\\.\\d+(-\\w+)?$/;\n      if (!versionPattern.test(templateObj.version)) {\n        warnings.push({\n          code: 'INVALID_VERSION_FORMAT',\n          message: 'Version should follow semantic versioning (e.g., 1.0.0)',\n          suggestion: 'Use format: MAJOR.MINOR.PATCH',\n        });\n      }\n    }\n\n    // Check for template file naming conventions\n    const fileName = path.basename(templatePath);\n    if (!fileName.startsWith('template.') && !fileName.includes('template')) {\n      warnings.push({\n        code: 'TEMPLATE_NAMING_CONVENTION',\n        message: 'Template file should follow naming convention',\n        suggestion:\n          'Consider naming template files as template.json or include \"template\" in the name',\n      });\n    }\n\n    // Validate tags if present\n    if (templateObj.tags) {\n      if (!Array.isArray(templateObj.tags)) {\n        errors.push({\n          code: 'INVALID_TAGS_TYPE',\n          message: 'Template tags must be an array',\n        });\n      } else {\n        const tags = templateObj.tags as unknown[];\n        const invalidTags = tags.filter(tag => typeof tag !== 'string');\n        if (invalidTags.length > 0) {\n          errors.push({\n            code: 'INVALID_TAG_TYPE',\n            message: 'All tags must be strings',\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Type guard for objects\n   */\n  private isObject(value: unknown): value is Record<string, unknown> {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n  }\n}\n\n/**\n * Load template from file path\n */\nasync function loadTemplate(templatePath: string): Promise<unknown> {\n  try {\n    const stats = await fs.stat(templatePath);\n\n    if (stats.isDirectory()) {\n      // Load from template.json in directory\n      const templateJsonPath = path.join(templatePath, 'template.json');\n      try {\n        const content = await fs.readFile(templateJsonPath, 'utf-8');\n        const template = JSON.parse(content);\n        // Add base path for relative file resolution\n        (template as Record<string, unknown>).basePath = templatePath;\n        return template;\n      } catch (error) {\n        throw new FileNotFoundError(\n          `Template directory must contain template.json`,\n          templateJsonPath,\n          { originalError: error }\n        );\n      }\n    } else {\n      // Load from single file\n      const content = await fs.readFile(templatePath, 'utf-8');\n\n      if (templatePath.endsWith('.json')) {\n        return JSON.parse(content);\n      }\n      if (templatePath.endsWith('.yaml') || templatePath.endsWith('.yml')) {\n        // TODO: Add YAML support when available\n        throw new TemplateEngineError(\n          'YAML templates not yet supported',\n          { templatePath },\n          'UNSUPPORTED_FORMAT'\n        );\n      } else {\n        throw new TemplateEngineError(\n          `Unsupported template format: ${path.extname(templatePath)}`,\n          { templatePath },\n          'UNSUPPORTED_FORMAT'\n        );\n      }\n    }\n  } catch (error) {\n    if (error instanceof TemplateEngineError) {\n      throw error;\n    }\n\n    if ((error as { code?: string }).code === 'ENOENT') {\n      throw new FileNotFoundError(\n        `Template file not found: ${templatePath}`,\n        templatePath\n      );\n    }\n\n    throw new TemplateEngineError(\n      `Failed to load template: ${error}`,\n      { templatePath },\n      'TEMPLATE_LOAD_ERROR'\n    );\n  }\n}\n\n/**\n * Find template file in configured paths\n */\nasync function findTemplate(\n  templateName: string,\n  config: Config\n): Promise<string | null> {\n  // If templateName is an absolute path, use it directly\n  if (path.isAbsolute(templateName)) {\n    try {\n      await fs.access(templateName);\n      return templateName;\n    } catch {\n      return null;\n    }\n  }\n\n  // If templateName is a relative path from cwd, try it first\n  const relativePath = path.resolve(process.cwd(), templateName);\n  try {\n    await fs.access(relativePath);\n    return relativePath;\n  } catch {\n    // Continue searching in configured paths\n  }\n\n  // Search in configured template paths\n  const searchPaths = [\n    ...config.templatePaths,\n    path.join(process.cwd(), 'templates'),\n    path.join(process.cwd(), '.cursor-prompt', 'templates'),\n  ];\n\n  for (const searchPath of searchPaths) {\n    try {\n      await fs.access(searchPath);\n\n      // Try direct file match\n      const directPath = path.join(searchPath, templateName);\n      try {\n        await fs.access(directPath);\n        return directPath;\n      } catch {\n        // Continue searching\n      }\n\n      // Try with extensions\n      const extensions = ['.json', '.template.json', '.yaml', '.yml'];\n      for (const ext of extensions) {\n        const extPath = path.join(searchPath, `${templateName}${ext}`);\n        try {\n          await fs.access(extPath);\n          return extPath;\n        } catch {\n          // Continue searching\n        }\n      }\n\n      // Try as directory with template.json\n      const dirPath = path.join(searchPath, templateName, 'template.json');\n      try {\n        await fs.access(dirPath);\n        return path.dirname(dirPath);\n      } catch {\n        // Continue searching\n      }\n    } catch {\n      // Search path doesn't exist, continue\n    }\n  }\n\n  return null;\n}\n\n/**\n * Display validation results\n */\nfunction displayResults(\n  results: TemplateValidationResult[],\n  options: ValidateOptions\n): void {\n  switch (options.format) {\n    case 'json':\n      logger.info(JSON.stringify(results, null, 2));\n      break;\n\n    case 'yaml':\n      // Simple YAML-like output\n      results.forEach((result, index) => {\n        logger.info(`- template: ${result.templateName}`);\n        logger.info(`  path: ${result.templatePath}`);\n        logger.info(`  valid: ${result.valid}`);\n        logger.info(`  errors: ${result.errors.length}`);\n        logger.info(`  warnings: ${result.warnings.length}`);\n        if (index < results.length - 1) logger.info('');\n      });\n      break;\n\n    case 'table':\n    default:\n      displayTableResults(results, options);\n      break;\n  }\n}\n\n/**\n * Display results in table format\n */\nfunction displayTableResults(\n  results: TemplateValidationResult[],\n  options: ValidateOptions\n): void {\n  logger.info('');\n\n  results.forEach((result, index) => {\n    // Template header\n    const status = result.valid\n      ? chalk.green('✅ VALID')\n      : chalk.red('❌ INVALID');\n    logger.info(chalk.cyan(`📋 ${result.templateName} ${status}`));\n    logger.info(chalk.gray(`   Path: ${result.templatePath}`));\n\n    // Schema validation summary\n    if (options.detailed) {\n      logger.info(chalk.gray('   Schema:'));\n      logger.info(\n        chalk.gray(\n          `     Required fields: ${result.schema.hasRequiredFields ? '✅' : '❌'}`\n        )\n      );\n      logger.info(\n        chalk.gray(\n          `     File references: ${result.schema.hasValidFileReferences ? '✅' : '❌'}`\n        )\n      );\n      logger.info(\n        chalk.gray(\n          `     Variables: ${result.schema.hasValidVariables ? '✅' : '❌'}`\n        )\n      );\n    }\n\n    // Display errors\n    if (result.errors.length > 0) {\n      logger.info(chalk.red(`\\n   Errors (${result.errors.length}):`));\n      result.errors.forEach(error => {\n        logger.info(chalk.red(`     • [${error.code}] ${error.message}`));\n        if (error.file && options.detailed) {\n          logger.info(chalk.gray(`       File: ${error.file}`));\n        }\n        if (error.line && options.detailed) {\n          logger.info(\n            chalk.gray(\n              `       Line: ${error.line}${error.column ? `, Column: ${error.column}` : ''}`\n            )\n          );\n        }\n      });\n    }\n\n    // Display warnings\n    if (result.warnings.length > 0) {\n      logger.info(chalk.yellow(`\\n   Warnings (${result.warnings.length}):`));\n      result.warnings.forEach(warning => {\n        logger.info(\n          chalk.yellow(`     • [${warning.code}] ${warning.message}`)\n        );\n        if (warning.suggestion && options.detailed) {\n          logger.info(chalk.gray(`       Suggestion: ${warning.suggestion}`));\n        }\n        if (warning.file && options.detailed) {\n          logger.info(chalk.gray(`       File: ${warning.file}`));\n        }\n      });\n    }\n\n    // Add spacing between templates\n    if (index < results.length - 1) {\n      logger.info('');\n    }\n  });\n\n  logger.info('');\n\n  // Summary\n  const validCount = results.filter(r => r.valid).length;\n  const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);\n  const totalWarnings = results.reduce((sum, r) => sum + r.warnings.length, 0);\n\n  logger.info(chalk.cyan('📊 Validation Summary:'));\n  logger.info(`   Templates validated: ${results.length}`);\n  logger.info(`   Valid: ${chalk.green(validCount)}`);\n  logger.info(`   Invalid: ${chalk.red(results.length - validCount)}`);\n  logger.info(`   Total errors: ${chalk.red(totalErrors)}`);\n  logger.info(`   Total warnings: ${chalk.yellow(totalWarnings)}`);\n}\n\n/**\n * Validate template command\n */\nexport async function validateCommand(\n  templatePath: string,\n  options: ValidateOptions = {}\n): Promise<void> {\n  try {\n    logger.info('🔍 Validating template...');\n\n    // Load configuration\n    const config = await loadConfig();\n\n    // Find template\n    const resolvedPath = await findTemplate(templatePath, config);\n    if (!resolvedPath) {\n      throw new FileNotFoundError(\n        `Template not found: ${templatePath}`,\n        templatePath\n      );\n    }\n\n    logger.debug(`Found template at: ${resolvedPath}`);\n\n    // Load template\n    const template = await loadTemplate(resolvedPath);\n\n    // Initialize validator\n    const validator = new TemplateValidator({\n      strict: options.strict,\n    });\n\n    // Validate template\n    const result = await validator.validateTemplate(template, resolvedPath);\n\n    // Display results\n    displayResults([result], options);\n\n    // Set exit status based on validation result\n    if (!result.valid) {\n      if (result.errors.length > 0) {\n        logger.error('❌ Template validation failed with errors');\n        throw new ValidationError(\n          `Template validation failed: ${result.errors.length} error(s)`,\n          'templatePath',\n          templatePath,\n          'TEMPLATE_VALIDATION',\n          { errors: result.errors },\n          'VALIDATION_FAILED'\n        );\n      }\n    } else {\n      const warningText =\n        result.warnings.length > 0\n          ? ` with ${result.warnings.length} warning(s)`\n          : '';\n      logger.success(`✅ Template validation passed${warningText}`);\n    }\n  } catch (error) {\n    if (error instanceof TemplateEngineError) {\n      logger.error(`❌ Validation failed: ${error.message}`);\n      throw error;\n    } else {\n      logger.error(`❌ Unexpected error during validation: ${error}`);\n      throw new TemplateEngineError(\n        `Validation command failed: ${error}`,\n        undefined,\n        'VALIDATE_ERROR'\n      );\n    }\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"lines-between-class-members","replacedBy":[]},{"ruleId":"lines-around-directive","replacedBy":["padding-line-between-statements"]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"spaced-comment","replacedBy":[]},{"ruleId":"global-require","replacedBy":[]},{"ruleId":"no-buffer-constructor","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]}]}]
